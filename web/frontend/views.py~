from django.contrib.auth.models import User
from django.shortcuts import render, render_to_response
from django.http import HttpResponseRedirect
from .forms import *
from django.contrib.auth.decorators import login_required
from .models import Workflow, Fragment, Task, UploadedFiles
from django.template import RequestContext
from django.contrib.auth import authenticate, login, logout
from django.http import HttpResponse

import json
import requests
import os


# Create your views here. This login required decorator is to not allow to any view without authenticating
@login_required(login_url="login/")
def home(request):
    return render(request, "home.html")


# This takes in a user name and password to login. This view doesn't require any login
def login_user(request):
    logout(request)
    if request.POST:
        username = request.POST['username']
        password = request.POST['password']

        user = authenticate(username=username, password=password)
        if user is not None:
            if user.is_active:
                login(request, user)
                return HttpResponseRedirect('/homepage/')
    return render_to_response('login.html', context_instance=RequestContext(request))


# This is the view for main page - what users sees when we goes to cloudmatcher.io
def main_page(request):
    if request.POST:
        username = request.POST['form-username']
        password = request.POST['form-password']
        user = authenticate(username=username, password=password)
        if user is not None:
            if user.is_active:
                login(request, user)
                return HttpResponseRedirect('/frontend/homepage')
    return render(request, 'frontend/welcome/home.html')


# Once the user logs in to cloudmatcher.io - he sees this page as the first thing
@login_required
def homepage(request):
    return render(request, 'frontend/index.html')


# If the user refreshes or goes to home page after login then he will see the index page with updated details
@login_required
def index(request):
    username = request.user.username
    owner = User.objects.get(username=username)
    wf_list = Workflow.objects.filter(owner=owner).exclude(status='COMPLETED').exclude(status='ERROR').exclude(
        status='CANCELLED').order_by('id')

    state_description = {}
    for element in Workflow.STATES:
        state_description[element[0]] = element[1]

    wf_info = []
    for wf in wf_list:
        _fragment = Fragment.objects.get(pk=wf.current_fragment_id)
        curr_frag_name = _fragment.name

        wf_details = {'id': wf.id, 'name': wf.name, 'owner': wf.owner, 'template': wf.template_id,
                      'curr_frag_id': wf.current_fragment_id, 'curr_frag_name': curr_frag_name, 'status': wf.status}
        wf_info.append(wf_details)

    recent_list = Workflow.objects.filter(owner=owner, status='COMPLETED').order_by('-id')
    info_txt = None
    if len(recent_list) > 0:
        recent = recent_list[0]
        template_id = recent.template_id
        if template_id == 'upload_table':
            fragment = Fragment.objects.filter(wf_id=recent.id).order_by('id')[0]
            task = Task.objects.get(pk=fragment.task_id)
            try:
                if task.file_name:
                    info_txt = 'Table ' + task.file_name + ' has been uploaded successfully!!'
            except IOError:
                info_txt = None

    context = {'wf_list': wf_list, 'state_description': state_description, 'username': username,
               'info_text': info_txt, 'wf_info': wf_info}

    return render(request, 'frontend/index.html', context)


# This view is used to handle new users who would like to register themselves to use CloudMatcher. It uses the
# registration form and the register.html page.
def register(request):
    if request.POST:
        form = RegistrationForm(request.POST)
        if form.is_valid():
            user = User.objects.create_user(username=form.cleaned_data['username'],
                                            password=form.cleaned_data['password1'],
                                            email=form.cleaned_data['email'])
            return HttpResponseRedirect('/')
        else:
            return render(request, 'userreg/register.html', {'form': form})
    return render(request, 'userreg/register.html')


# This method will send and receive metadata information from Meta Manager. This method will send the data from the
# web application to the meta core and will also process the response received from Meta Manager. This method should
# be very fast and should process all the calls quickly.
def send_receive_meta_manager(input_msg, method):

    # Sending the payload to the meta core by first converting the message into JSON format and then calling the
    # required MM method.
    send_message = json.dumps(input_msg)
    url = URL + method
    req = requests.post(url, data=send_message)

    # Receiving response from the meta core and processing it
    response = json.loads(req.text)
    return response


# Upload data view is used whenever the user wants to upload a new dataset. This view requires the user to
# login into the system.
@login_required
def upload_data(request):
    if request.method == 'POST':
        # Get the form data. For upload_data we know that UploadDatasetForm will be used.
        form = UploadDatasetForm(request.POST, request.FILES)
        # Check if the form is valid (whether all required information was filled or not by the user)
        if form.is_valid():
            # Fetching the workflow id from the request
            wf_id = request.POST['wfid']
            frag_id = request.POST['fragid']

            print('post request: ', request.POST)
            print('post info: ', wf_id)
            print('frag id: ', frag_id)

            # Save the uploaded file first in the uploaded files database
            in_file = request.FILES['docfile']
            submit_by = User.objects.get(username=request.user.username)
            _upload = UploadedFiles.objects.create(owner=submit_by)
            _upload.wf_id = wf_id
            _upload.doc_file = in_file
            _upload.save()

            logger.info('Uploaded file saved successfully to the database: ' + str(_upload.id))
            _up = UploadedFiles.objects.get(pk=_upload.id)
            file_loc = str(_up.doc_file.file.name)
            print(file_loc)

            # Fetching form information and create payload to call meta core rest api
            payload = {'user': request.user.username, 'wf_id': wf_id, 'file_name': request.POST['name'],
                       'info': request.POST['description'], 'file_loc': file_loc, 'celery_status': None,
                       'frag_id': frag_id}

            response_msg = send_receive_meta_manager(payload, 'workflow_update')
            return HttpResponse(json.dumps(response_msg), content_type="application/json")
        else:
            # If the form is not valid, it will be returned back to the user with status error
            logger.info("Invalid form")
    elif request.method == 'GET':
        owner = request.user.username
        # Checking if a Workflow id is already assigned or not
        using_wf_id = request.GET.get('wf_id', False)
        using_frag_id = request.GET.get('frag_id', False)

        # Creating payload to send as message to the create_workflow api of meta manager
        if not using_wf_id:
            payload = {'user': owner, 'template': 'upload_table'}
            received_msg = send_receive_meta_manager(payload, 'create_workflow')

            print('received_msg: ', received_msg)

            # Reading the workflow id and form details received from the Meta Manager (like the form)
            wf_id = received_msg['wf_id']
            message = received_msg['message'][0]
            print('Message: ', message)
            current_frag_id = int(message['current_frag_id'])
        else:
            wf_id = using_wf_id
            current_frag_id = using_frag_id

        print('GET request: ', wf_id, current_frag_id)

        # Returning the html page back to the user
        form = UploadDatasetForm(initial={'wfid': wf_id, 'fragid': current_frag_id})
        return render(request, 'frontend/create/upload_data.html', {'form': form, 'wf_id': wf_id,
                                                                    'frag_id': current_frag_id})

    msg = {
        'status': 'ERROR',
        'info': 'Error in processing the form post method!'
    }
    return HttpResponse(json.dumps(msg), content_type="application/json")


@login_required
def get_profile_status(request):
    if request.method == 'POST':
        print('Error! This call should not be a post method')
    else:
        # This will be a GET method and first we will fetch the dag id and user id from the request
        wf_id = request.GET['wf_id']
        user = request.user.username

        # Creating payload to be send to the meta core api
        payload = {'user': user, 'wf_id': wf_id}
        received_msg = send_receive_meta_manager(payload, 'get_workflow_status')

        message = received_msg['message'][0]
        frag_name = message['frag_name']

        # If the fragment name is get_confirmation, it is assumed that the profile fragment is completed and so we
        # mark the profile task status as completed
        if frag_name == 'get_confirmation':
            received_msg['task_status'] = 'COMPLETED'
        else:
            received_msg['task_status'] = 'IN_PROGRESS'

        print('get_profile_status: ', received_msg, message)

        frag_id = message['frag_id']
        received_msg['frag_id'] = frag_id

        received_msg['workflow_status'] = message['workflow_completed']

        print('get_profile_status: ', received_msg, message)

        return HttpResponse(json.dumps(received_msg), content_type="application/json")
    msg = {
        'task_status': 'Error',
        'info': 'Some error in processing!'
    }
    return HttpResponse(json.dumps(msg), content_type="application/json")


@login_required
def get_profile_confirmation(request):
    print('get_profile_confirmation: ', request.GET)
    wf_id = request.GET['wf_id']
    print('get_profile_confirmation: ', wf_id)

    _wf = Workflow.objects.get(pk=wf_id)
    frag_id = _wf.current_fragment_id

    # Creating payload to be send to the meta core api
    payload = {'user': request.user.username, 'wf_id': wf_id, 'file_name': None, 'info': 'Workflow finished',
               'file_loc': None, 'celery_status': None, 'frag_id': frag_id}

    received_msg = send_receive_meta_manager(payload, 'workflow_update')

    print('received_msg = ', received_msg)

    message = received_msg['message']
    received_msg['workflow_status'] = message['workflow_completed']

    print('get_profile_confirmation: ', received_msg)

    return HttpResponse(json.dumps(received_msg), content_type="application/json")


@login_required
def see_profile(request):
    wf_id = request.GET['wf_id']
    owner = request.user.username

    output_path = 'output/%s/%d/' % (owner, eval(wf_id))
    profile_file = output_path + 'profile_results.txt'

    print('Profile file path: ', profile_file)

    if ENV is 'PROD':
        try:
            if not os.path.exists(profile_file):
                try:
                    script = '/home/ec2-user/CloudMatcher/pycloudmatch/scripts/getFile.sh'
                    output_dir = "/%s/%s/%d/%s/" % ('output', owner, eval(wf_id), 'profile_results.txt')
                    output = subprocess.check_output([script, output_dir, profile_file])
                except subprocess.CalledProcessError as e:
                    print(e.output)
        except IOError as e:
            print(e)

    results = json.load(open(profile_file))

    _wf = Workflow.objects.get(pk=wf_id)

    table_stats = results['table']

    num_of_rows = table_stats.get('num_rows')
    num_of_attr = table_stats.get('num_of_attributes')
    mem_size = table_stats.get('mem_size')
    avg_rec_size = table_stats.get('avg_record_size')

    headers = table_stats.get('list_of_attributes')

    rows = results['sample']

    attr_info = results['attr_info']

    return render(request, 'frontend/create/see_profile.html', {'headers': headers, 'rows': rows,
                                                                'num_of_attrs': num_of_attr, 'mem_size': mem_size,
                                                                'avg_record_size': avg_rec_size,
                                                                'num_of_rows': num_of_rows,
                                                                'attr_info': attr_info, 'wf_id': _wf.id,
                                                                'frag_id': _wf.current_fragment_id,
                                                                'wf_name': _wf.name})


@login_required
def view_profile(request):
    wf_id = request.GET['wf_id']
    owner = request.user.username

    output_path = 'output/%s/%d/' % (owner, eval(wf_id))
    profile_file = output_path + 'profile_results.txt'

    if ENV is 'PROD':
        try:
            if not os.path.exists(profile_file):
                try:
                    script = '/home/ec2-user/CloudMatcher/pycloudmatch/scripts/getFile.sh'
                    output_dir = "/%s/%s/%d/%s/" % ('output', owner, eval(dag_id), 'profile_results.txt')
                    output = subprocess.check_output([script, output_dir, profile_file])
                except subprocess.CalledProcessError as e:
                    print(e.output)
        except IOError as e:
            print(e)

    results = json.load(open(profile_file))

    _wf = Workflow.objects.get(pk=wf_id)

    table_stats = results['table']

    num_of_rows = table_stats.get('num_rows')
    num_of_attr = table_stats.get('num_of_attributes')
    mem_size = table_stats.get('mem_size')
    avg_rec_size = table_stats.get('avg_record_size')

    headers = table_stats.get('list_of_attributes')

    rows = results['sample']

    attr_info = results['attr_info']

    return render(request, 'frontend/create/view_profile.html', {'headers': headers, 'rows': rows,
                                                                 'num_of_attrs': num_of_attr, 'mem_size': mem_size,
                                                                 'avg_record_size': avg_rec_size,
                                                                 'num_of_rows': num_of_rows,
                                                                 'attr_info': attr_info, 'wf_id': wf_id,
                                                                 'frag_id': _wf.current_fragment_id,
                                                                 'wf_name': _wf.name})


@login_required
def wf_progress(request, wf_id):
    wf_list = Workflow.objects.filter(id=wf_id).order_by('id')
    frag_list = Fragment.objects.filter(wf_id=wf_id).order_by('id')
    task_list = Task.objects.filter(wf_id=wf_id).order_by('id')

    wf_state_description = {}
    for element in Workflow.STATES:
        wf_state_description[element[0]] = element[1]

    frag_state_description = {}
    for element in Fragment.STATES:
        frag_state_description[element[0]] = element[1]

    task_state_description = {}
    for element in Task.STATES:
        task_state_description[element[0]] = element[1]

    context = {'wf_list': wf_list, 'frag_list': frag_list, 'task_list': task_list,
               'wf_state_desc': wf_state_description, 'frag_state_desc': frag_state_description,
               'task_state_desc': task_state_description, 'wf_id': wf_id}

    return render(request, 'frontend/create/wf_progress.html', context)
