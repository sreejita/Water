from django.db import models
from django.contrib.postgres.fields import ArrayField, JSONField


# Create your models here.

class DataFile(models.Model):
    file = models.FileField(blank=True, upload_to="data")

    def __str__(self):
        return self.file.name


class Job(models.Model):
    STATES = (
        ('CREATE_UPLOAD_A', 'Create step: upload table A'),
        ('CREATE_UPLOAD_B', 'Create step: upload table B'),
        ('SHOW_PROFILE', 'Job finished.'),
        ('CREATED', 'Job created'),
        ('SELECT_MODE', 'Select mode: User or Crowd'),
        ('GOLDEN_MODE_FILE_UPLOAD', 'Golden mode file upload'),
        ('TRIGGER_PIPELINE', 'Trigger pipeline'),
        ('TRIGGER_BLOCKING', 'Trigger blocking: seed generation'),
        ('TRAINING', 'Active learning: labels required for training'),
        ('ACTIVE_LEARNING_END', 'Active learning finished'),
        ('ACTIVE_LEARNING_END_MATCHING', 'Active learning matching stage finished'),
        ('SAMPLES_START', 'Creating samples'),
        ('SAMPLES_READY', 'Active learning seed: Positive labels needed'),
        ('SAMPLE_PAIRS_GENERATED', 'Sample pairs generated for training'),
        ('ADDITIONAL_POSITIVE_LABELS_NEEDED', 'Additional positive examples needed'),
        ('NEGATIVE_LABELS_NEEDED', 'Active learning seed: Negative labels needed'),
        ('ADDITIONAL_NEGATIVE_LABELS_NEEDED', 'Additional negative labels needed'),
        ('QUESTION_NEEDED', 'Question templated needed'),
        ('IN_PROGRESS', 'Please wait. Task is executing..'),
        ('COMPLETED', 'Job completed'),
        ('ERROR', 'Error: click for more details'),
        ('CROWD_SOURCING_IN_PROGRESS', 'HITS are uploaded to AMT: crowdsourcing in progress'),
        ('EVAL_RULES_TRAINING', 'Evaluating rules: training data'),
        ('SAMPLE_PAIRS_DONE', 'Sample pairs generated'),
        ('FEATURE_VECTORS_DONE', 'Feature vectors generated'),
        ('GET_BLOCKING_RULES_COMPLETED', 'Get blocking rules'),
        ('EVAL_RULES_FINISH', 'Evaluation of rules completed'),
        ('CROWD_LABELING_IN_PROGRESS', 'Crowdsourcing (labeling) in progress..'),
        ('GET_FEATURES_DONE', 'Features selected'),
        ('EVAL_RULES_CROWD_LABELING_IN_PROGRESS', 'Evaluate rules crowd labeling'),
        ('APPLY_BLOCKING_RULES_DONE', 'Apply blocking rules completed'),
        ('ACTIVE_LEARNING_PREP_DONE', 'Preparation for Active learning done'),
        ('', 'Testing'),
    )
    fileA = models.FileField(upload_to="data", blank=True, null=True)
    headerA = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    firstrowsA = JSONField(blank=True, null=True)
    fileB = models.FileField(upload_to="data", blank=True, null=True)
    headerB = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    firstrowsB = JSONField(blank=True, null=True)
    goldendata = models.FileField(upload_to="data", null=True, blank=True)
    columnmappings = models.FileField(upload_to="data", null=True, blank=True)
    featurecosts = models.FileField(upload_to="data", null=True, blank=True)

    posexampleids = models.CharField(blank=True, max_length=200, null=True)
    negexampleids = models.CharField(blank=True, max_length=200, null=True)

    additionalPos1A = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    additionalPos1B = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    additionalPos2A = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    additionalPos2B = ArrayField(models.CharField(max_length=200), blank=True, null=True)

    additionalNeg1A = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    additionalNeg1B = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    additionalNeg2A = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    additionalNeg2B = ArrayField(models.CharField(max_length=200), blank=True, null=True)

    sampleQuestion = models.TextField(blank=True, null=True)

    jobstate = models.CharField(choices=STATES, max_length=50)
    prevJobState = models.CharField(choices=STATES, max_length=50, null=True)
    errormessage = models.CharField(max_length=200, null=True)
    errorRetryCount = models.IntegerField(default=0, blank=False)
    mode = models.CharField(max_length=10, null=True)
    process_type = models.CharField(max_length=10, null=True)
    name = models.CharField(blank=False, max_length=50)
    owner = models.ForeignKey("auth.User")
    email = models.EmailField(max_length=100, blank=True, null=True)
    al_iter = models.PositiveSmallIntegerField(default=0)
    idColumnA = models.CharField(blank=True, max_length=50)
    idColumnB = models.CharField(blank=True, max_length=50)
    numPairsToLabel = models.IntegerField(default=1, blank=False)
    reward_amount = models.FloatField(blank=True, null=True)
    assignment_duration = models.IntegerField(blank=True, null=True)
    auto_approval_delay = models.IntegerField(blank=True, null=True)
    hit_lifetime = models.IntegerField(blank=True, null=True)
    initial_assignment = models.IntegerField(blank=True, null=True)
    mturk_access_key = models.CharField(max_length=300, null=True)
    mturk_secret_key = models.CharField(max_length=300, null=True)

    title = models.CharField(max_length=200, null=True)
    description = models.CharField(max_length=200, null=True)
    keywords = models.CharField(max_length=200, null=True)
    introduction = models.CharField(max_length=4000, null=True)
    instructions = models.CharField(max_length=4000, null=True)
    question = models.CharField(max_length=200, null=True)
    matching_attributes = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    answer_format = models.CharField(max_length=200, null=True)
    attributes_to_match = ArrayField(models.CharField(max_length=200), blank=True, null=True)
    comments = models.CharField(max_length=200, blank=True, null=True)

    # Have added this method to keep a track of previous Task
    # For 1) the purpose retry in case of failures 2) Increase visibility in UI
    def setNextJobState(self, value):
        if self.jobstate is not None:
            self.prevJobState = self.jobstate
        else:
            self.prevJobState = value
        self.jobstate = value
        if self.jobstate != 'ERROR' and self.prevJobState != "ERROR":
            self.errorRetryCount = 0

    def __str__(self):
        return str(self.id)


# Used as metric logger for every task
# 1) Can hold information like - no of iterations in Active learning
class Log(models.Model):
    jobId = models.OneToOneField(Job, on_delete=models.CASCADE, primary_key=True)
    log = models.TextField(null=True)

    def captureLogForJobId(self, Id):
        Log.Job
        self.list = [Id]

    def finishAndRecord(self, task, metricPair):
        pop = self.list.pop()
        if pop == task:
            stringtoAppend = '[', str(metricPair.first), ':', str(metricPair.second), ']'
            self.string += stringtoAppend


# YG - creating a model to store dag related information. This model will be used by meta core to store
# DAG related information and to track current DAG status.
class Workflow(models.Model):
    STATES = (
        ('CREATED', 'Workflow created'),
        ('STARTED', 'Workflow started'),
        ('IN_PROGRESS', 'Workflow in progress'),
        ('COMPLETED', 'Workflow completed'),
        ('ERROR', 'Error in workflow'),
        ('CANCELLED', 'Workflow cancelled'),
    )
    name = models.CharField(max_length=50, null=True, blank=True)
    owner = models.ForeignKey("auth.User")
    template_id = models.CharField(max_length=50, null=True, blank=True)
    current_fragment_id = models.CharField(max_length=100, null=True, blank=True)
    status = models.CharField(choices=STATES, max_length=50, blank=True, null=True)
    workflow = models.CharField(max_length=2000, null=True, blank=True)
    info = models.CharField(max_length=100, null=True, blank=True)

    def __str__(self):
        return str(self.id)


# YG - creating a model to store workflow fragment information. This model will be updated by the meta core when a
# particular fragment is completed.
class Fragment(models.Model):
    STATES = (
        ('READY', 'Ready for execution'),
        ('CREATED', 'Created a fragment'),
        ('STARTED', 'Started fragment'),
        ('IN_PROGRESS', 'Fragment is running'),
        ('PENDING', 'Waiting for input'),
        ('COMPLETED', 'Completed'),
        ('ERROR', 'Error in processing'),
        ('CANCELLED', 'Fragment cancelled'),
    )
    ENGINES = (
        ('UI', 'Web application engine'),
        ('BATCH', 'Batch processing engine'),
        ('CROWD', 'Crowd sourcing engine')
    )

    owner = models.ForeignKey("auth.User")
    name = models.CharField(max_length=50, null=True, blank=True)
    status = models.CharField(choices=STATES, max_length=50, blank=True, null=True)
    execution_engine = models.CharField(choices=ENGINES, max_length=50, blank=True, null=True)
    num_of_nodes_in_fragment = models.IntegerField(default=0, blank=True, null=True)
    wf_id = models.IntegerField(blank=True, null=True)
    task_id = models.IntegerField(blank=True, null=True)
    fragment = models.CharField(max_length=2000, null=True, blank=True)
    celery_id = models.CharField(max_length=50, null=True, blank=True)
    info = models.CharField(max_length=100, null=True, blank=True)

    def __str__(self):
        return str(self.id)


# YG - creating a model to store task(node) related information. This model will be updated by the execution engine
# responsible for executing the particular task.
class Task(models.Model):
    STATES = (
        ('READY', 'Ready for execution'),
        ('CREATED', 'Created a task'),
        ('STARTED', 'Started task'),
        ('IN_PROGRESS', 'Task is running'),
        ('PENDING', 'Waiting for input'),
        ('COMPLETED', 'Completed'),
        ('ERROR', 'Error in processing'),
    )

    wf_id = models.IntegerField(blank=True, null=True)
    fragment_id = models.IntegerField(blank=True, null=True)
    owner = models.ForeignKey("auth.User")
    name = models.CharField(max_length=50, null=True, blank=True)
    status = models.CharField(choices=STATES, max_length=50, blank=True, null=True)
    doc_file = models.FileField(upload_to="data", blank=True, null=True)
    in_param = models.CharField(max_length=1000, null=True, blank=True)
    output = models.CharField(max_length=5000, null=True, blank=True)
    file_loc = models.CharField(max_length=500, null=True, blank=True)
    file_name = models.CharField(max_length=500, null=True, blank=True)
    info = models.CharField(max_length=100, null=True, blank=True)

    def __str__(self):
        return str(self.id)


# Making this database now to keep track of uploaded files by the user for any workflow. It will have its own
# identifier but will contain the workflow id as well.
class UploadedFiles(models.Model):
    wf_id = models.IntegerField(blank=True, null=True)
    owner = models.ForeignKey("auth.User")
    doc_file = models.FileField(upload_to="data", blank=True, null=True)

    def __str__(self):
        return str(self.id)
